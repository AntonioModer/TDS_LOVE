--[[
version 0.0.1
@todo 
	- как ссылаться на энтити, чтобы даже после сохранения карты ссылка сохранялась?
		-? version1 [
			-?NOYES по имени энтити
				- должно быть уникальное имя
				- или хранить ссылку на тригер и в энтити, чтобы энтити проверял
			@todo - посмотри как в Light текстуру теней сохранял с уникальным именем
				-YES отдельная глобальная одна таблица с уникальными именами энтитей, с которыми соединен тригер
					- triggersConnectedEntitys['entityNameUnique'] = <entity>(загрузили в память) / nil / false(только когда сохраняем в файл)
					- нужно каждый раз, при соединении тригера с энтити, проверять уникальность имени с таблицей
					- энтити ничего не нужно делать для этого
					- таблицу нужно сохранять при сохранении мира
					- таблицу нужно загружать из сохранения и сохранять в файле в первую очередь, а затем уже энтити и тригеры
					- в тригере и энтити сохраняется имя
					- при загрузке уровня загружаются в эту таблицу ссылки памяти на таблицы энтитей
						- при создании энтити нужно проверять, есть ли в энтити имя для триггера и есть ли это имя в таблице triggersConnectedEntitys
					-?NO уникальное имя лучше с приставкой (будет меньше совпадений, но память строк увеличится): название собственного класса, т.к. в основном создается дочерние от Entity объекты (пример: Door_0x322efe28_same10)
						- BUG если имя класса изменить, то будет несовпадение имен
						* 0x322efe28 - это Шестнадцатеричная система счисления(322efe28 = число 841940520)
						- изменить в Light это				
					-?NO вообще тогда лучше для каждой энтити создавать уникальное имя, а не только ради тригера
						* не нужно это, т.к. имя можно генерировать быстро где угодно, и только зря память занимать
			-?NO ссылка на таблицу
		]
		@todo -? version2 
			* энтити не должно знать о тригере
			- тригер создает уникальное имя в энтити для своих нужд; хранит это имя у себя
				- нужна постоянная таблица с уникальными именами, чтобы не было повторений имен
					- world.entitysNamesUnique['entityNameUnique'] = <entity> <nil>
			- как загружать мир
				- после загрузки уровня нужно для каждого тригера найти ссылки на привязанные энтити по уникальным именам этих привязанных энтитей
					-NO методом перебора
						- нужно перебрать каждую энтити в мире, если она имеет уникальное имя, то проверить это имя в каждом тригере, если оно есть в тригере, то добавить ссылку на эту энтити в триггер
					@todo - ссылочный метод, сначало этот
						- перед загрузкой уровня создаем специальную таблицу world.entitysNamesUnique['entityNameUnique'] = <entity> <nil>
							- и в методе Entity:newObject() добавлять свою ссылку в world.entitysNamesUnique таблицу, если в энтити есть уникальное имя
								(появляется зависимость внешняя для world, не очень хорошо, зато оптимизированно, код запутаннее, но гибче)
								-! нужно не забывать что энтитя существует только в созданном world
								- учитывать то, что энтити может создаваться во время загрузки world, смотри world.loadingNow
							- в Entity:destroy() нужно удалять из world.entitysNamesUnique ссылку
							- потом каждый тригер берет по именам привязанных к себе энтитей ссылки из world.entitysNamesUnique таблицы
								-NO а потом world.entitysNamesUnique таблица удаляется
					- ссылочно переборный метод
						- перед загрузкой уровня создаем специальную таблицу world.entitysNamesUnique['entityNameUnique'] = <entity> <nil>
							- потом после загрузки мира нужно перебрать каждую энтити в мире, если она имеет уникальное имя, то добавляем ссылку в world.entitysNamesUnique
							  (нету зависимости внешней для world, хорошо, но не оптимизированно, код простой)
								- а затем каждый тригер берет по именам привязанных к себе энтитей ссылки из этой world.entitysNamesUnique таблицы
									-NO потом world.entitysNamesUnique таблица удаляется
--]]


local ClassParent = require('code.classes.Entity')
local ThisModule
if ClassParent then
	ThisModule = ClassParent:_newClass(...)
else
	ThisModule = {}
end


-- variables private
-- ...

-- variables protected, only in Class
-- ...

-- variables public


-- methods private
-- ...

-- methods protected
-- ...

-- methods public

function ThisModule:newObject(arg)
	if self.destroyed then self:destroyedError() end
	
	local arg = arg or {}
	local object = ClassParent.newObject(self, arg)
	
	
	return object
end

return ThisModule